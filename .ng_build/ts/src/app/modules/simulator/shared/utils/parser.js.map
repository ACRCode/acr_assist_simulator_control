{"version":3,"sources":["parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"","sourcesContent":["declare var require: any;\nexport class Parser {\nprivate stringParser: any = require('string');\n/**\n * @param {?} xmlData\n * @return {?}\n */\nparseToJson(xmlData: string): JSON {\n        let /** @type {?} */ jsonResult: JSON;\n        xmlData = this.CleanUp(xmlData);\n        const /** @type {?} */ parseString =  require('xml2js').parseString;\n        parseString(xmlData, {explicitRoot : false, explicitArray : false, attrkey : 'Attr'} , function (err, result) {\n            jsonResult  = result;\n       });\n      return jsonResult;\n    }\n/**\n * @param {?} str\n * @return {?}\n */\npublic IsJsonString(str: string) {\n        try {\n            JSON.parse(str);\n        } catch ( /** @type {?} */e) {\n            return false;\n        }\n        return true;\n    }\n/**\n * @param {?} xmlstr\n * @return {?}\n */\nCleanUp(xmlstr: string) {\n        xmlstr = xmlstr.replace(/<!--[\\s\\S]*?-->/g, ''); // remove commented lines\n        xmlstr = xmlstr.replace(/\\n|\\t|\\r/g, ' ');  // replace special characters\n        xmlstr = xmlstr.replace(/ {1,}<|\\t{1,}</g, '<'); // replace leading spaces and tabs\n        xmlstr = xmlstr.replace(/> {1,}|>\\t{1,}/g, '>'); // replace trailing spaces and tabs\n        xmlstr = xmlstr.replace(/<\\?[^>]*\\?>/g, ''); // delete docType tags\n        xmlstr = xmlstr.replace(/\\\"/g, '\"');\n\n\n\n        let /** @type {?} */ dataElements = this.stringParser(xmlstr).between('<DataElements>', '</DataElements>').s;\n        const /** @type {?} */ tempDataElements = dataElements;\n\n        dataElements = this.CleanUpTextTemplate(dataElements);\n        xmlstr = xmlstr.replace(tempDataElements, dataElements);\n\n        let /** @type {?} */ endPoints = this.stringParser(xmlstr).between('<EndPoints>', '</EndPoints>').s;\n        const /** @type {?} */ tempEndPoints = endPoints;\n        endPoints = this.CleanUpTemplatePartials(endPoints);\n        endPoints = this.CleanUpReportText(endPoints, '<ReportText SectionId=\"findings\">', '<ReportText SectionId=\\'findings\\'>');\n        endPoints = this.CleanUpReportText(endPoints, '<ReportText SectionId=\"impression\">', '<ReportText SectionId=\\'impression\\'>');\n        endPoints = this.CleanUpReportText(endPoints, '<ReportText SectionId=\"recommendation\">',\n                                                '<ReportText SectionId=\\'recommendation\\'>');\n        return xmlstr.replace(tempEndPoints, endPoints);\n\n    }\n/**\n * @param {?} source\n * @return {?}\n */\nCleanUpTextTemplate(source: string) {\n\n        const /** @type {?} */ startMatch = '<TextExpression>';\n        const /** @type {?} */ endMatch = '</TextExpression>';\n        if (this.stringParser(source).contains(startMatch)) {\n            const /** @type {?} */ str1 = this.stringParser(source).between('', startMatch).s + startMatch;\n            const /** @type {?} */ temp = this.stringParser(source).between(str1).s;\n            const /** @type {?} */ str2 = this.stringParser(temp).between('', endMatch).s;\n            const /** @type {?} */ _str2 = str2;\n            const /** @type {?} */ morphedText = this.MorphReportText(str2);\n            let /** @type {?} */ newText = str1 + morphedText;\n            const /** @type {?} */ str3 = this.stringParser(temp).between(_str2);\n            if (str3 !== '') {\n                newText += this.CleanUpTextTemplate(str3);\n            }\n            return newText;\n        }\n        return source;\n    }\n/**\n * @param {?} source\n * @param {?} match1\n * @param {?=} match2\n * @return {?}\n */\nCleanUpReportText(source: string, match1: string, match2?: string) {\n\n        if (!(this.stringParser(source).contains(match1) || this.stringParser(source).contains(match2))) {\n          return source;\n        }\n\n        const /** @type {?} */ match = this.stringParser(source).contains(match1) ? match1 : match2;\n        const /** @type {?} */ reportTextClosing = '</ReportText>';\n\n        const /** @type {?} */ str1 = this.stringParser(source).between('', match).s + match;\n        const /** @type {?} */ temp = this.stringParser(source).between(str1).s;\n        const /** @type {?} */ str2 = this.stringParser(temp).between('', reportTextClosing).s;\n\n        // TODO : Verify this logic\n        const /** @type {?} */ _str2 = str2;\n        const /** @type {?} */ morphedText = this.MorphReportText(str2);\n        let /** @type {?} */ newText = str1 + morphedText;\n        const /** @type {?} */ str3 = this.stringParser(temp).between(_str2);\n        if (str3 !== '') {\n            newText += this.CleanUpReportText(str3, match);\n       }\n       return newText;\n\n\n    }\n/**\n * @param {?} source\n * @return {?}\n */\nCleanUpTemplatePartials(source: string) {\n        const /** @type {?} */ match = '<TemplatePartial';\n        const /** @type {?} */ templatePartialClosing = '</TemplatePartial>';\n        if (this.stringParser(source).contains(match)) {\n            const /** @type {?} */ templateTagElement = match + this.stringParser(source).between(match, '>') + '>';\n            const /** @type {?} */ str1 = this.stringParser(source).between('', templateTagElement) + templateTagElement;\n            const /** @type {?} */ str2 = this.stringParser(source).between(templateTagElement, templatePartialClosing);\n            const /** @type {?} */ str3 = this.stringParser(source).between(templatePartialClosing);\n            const /** @type {?} */ morphedText = this.MorphReportText(str2);\n            return str1 + morphedText + templatePartialClosing + this.CleanUpTemplatePartials(str3);\n        } else {\n            return source;\n        }\n    }\n/**\n * @param {?} str2\n * @return {?}\n */\nMorphReportText(str2: string) {\n\n        const /** @type {?} */ text = [];\n        while (str2.trim() !== '') {\n            if (this.stringParser(str2).startsWith('<SectionIf') || this.stringParser(str2).startsWith('<SectionIfNot') ||\n            this.stringParser(str2).startsWith('<SectionIfValue') || this.stringParser(str2).startsWith('<SectionIfValueNot')) {\n                const /** @type {?} */ temp = str2;\n                const /** @type {?} */ sectionContent = this.stringParser(str2).between('', '>') + '>';\n                const /** @type {?} */ newStr2 = str2.replace(sectionContent, '');\n                const /** @type {?} */ morphedText = '<Text>' + sectionContent + this.MorphReportText(newStr2);\n                text.push(morphedText);\n                str2 = this.stringParser(str2).between(temp).s;\n            } else if (this.stringParser(str2).startsWith('</SectionIf>')) {\n                text.push('</SectionIf>' + '</Text>');\n                str2 = this.stringParser(str2).between('</SectionIf>').s;\n            } else if (this.stringParser(str2).startsWith('</SectionIfNot>')) {\n                text.push('</SectionIfNot>' + '</Text>');\n                str2 = this.stringParser(str2).between('</SectionIfNot>').s;\n            } else if (this.stringParser(str2).startsWith('</SectionIfValue>')) {\n                text.push('</SectionIfValue>' + '</Text>');\n                str2 = this.stringParser(str2).between('</SectionIfValue>').s;\n            } else if (this.stringParser(str2).startsWith('</SectionIfValueNot>')) {\n                text.push('</SectionIfValueNot>' + '</Text>');\n                str2 = this.stringParser(str2).between('</SectionIfValueNot>').s;\n            } else if (this.stringParser(str2).startsWith('<')) {\n                const /** @type {?} */ temp = this.stringParser(str2).between('', '>') + '>';\n                text.push('<Text>' + temp + '</Text>');\n                str2 = this.stringParser(str2).between(temp).s;\n            } else {\n                let /** @type {?} */ temp = str2;\n                if (str2.indexOf('<') !== -1) {\n                  temp = this.stringParser(str2).between('', '<');\n                }\n                text.push('<Text>' + temp + '</Text>');\n                str2 = str2.replace(temp, '');\n\n            }\n        }\n\n        return text.join(' ');\n    }\n/**\n * @param {?} xmlstr\n * @param {?} startString\n * @param {?} endString\n * @return {?}\n */\nGetSubstring(xmlstr: string, startString: string, endString: string) {\n        const /** @type {?} */ startIndex = xmlstr.indexOf(startString) + startString.length;\n        const /** @type {?} */ endIndex = xmlstr.indexOf(endString);\n        return xmlstr.substring(startIndex, endIndex);\n    }\n/**\n * @param {?} string\n * @param {?} subString\n * @param {?} allowOverlapping\n * @return {?}\n */\noccurrences(string, subString, allowOverlapping) {\n        string += '';\n        subString += '';\n        if (subString.length <= 0) {\n          return (string.length + 1);\n        }\n\n        let /** @type {?} */ n = 0, /** @type {?} */ pos = 0;\n        const /** @type {?} */ step = allowOverlapping ? 1 : subString.length;\n        while (true) {\n            pos = string.indexOf(subString, pos);\n            if (pos >= 0) {\n                ++n;\n                pos += step;\n            } else  {\n              break;\n            }\n        }\n        return n;\n    }\n\n}\n\nfunction Parser_tsickle_Closure_declarations() {\n/** @type {?} */\nParser.prototype.stringParser;\n}\n\n\n\n"]}